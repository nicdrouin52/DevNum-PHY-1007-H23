import numpy as np

from src.coordinate_and_position import CoordinateSystem
from src.fields import ScalarField


class LaplaceEquationSolver:
    """
    A Laplace equation solver used to compute the resultant potential field P in 2D-space generated by a constant
    voltage field V (for example due to wires).
    """

    def __init__(self, nb_iterations: int = 1000):
        """
        Laplace solver constructor. Used to define the number of iterations for the relaxation method.

        Parameters
        ----------
        nb_iterations : int
            Number of iterations performed to obtain the potential by the relaxation method (default = 1000).
        """
        self.nb_iterations = nb_iterations

    def _solve_in_cartesian_coordinate(
            self,
            constant_voltage: ScalarField,
            delta_x: float,
            delta_y: float
    ) -> ScalarField:
        """
        Solve the Laplace equation to compute the resultant potential field P in 2D-space.

        Parameters
        ----------
        constant_voltage : ScalarField
            A scalar field V : ℝ² → ℝ ; (x, y) → V(x, y), where V(x, y) is the electrical components' voltage at a
            given point (x, y) in space.
        delta_x : float
            Small discretization of the x-axis.
        delta_y : float
            Small discretization of the y-axis.

        Returns
        -------
        potential : ScalarField
            A scalar field P : ℝ² → ℝ ; (x, y) → P(x, y), where P(x, y) is the electric potential at a given point
            (x, y) in space. The difference between P and V is that P gives the potential in the whole world, i.e inside
            the electrical components and in the empty space between the electrical components, while the field V
            always gives V(x, y) = 0 if (x, y) is not a point belonging to an electrical component of the circuit.
        """
        # on a déja la matrice des sources de potentiel
        P = constant_voltage.copy()
        # copie de la première matrice
        P_copie = constant_voltage.copy()
        
        #on initialise une liste vide pour les points constants dans la matrice
        point_ct = []
        for indice_i, i in enumerate(constant_voltage):
            for indice_j, j in enumerate(i):
                if j != 0:
                    point_ct.append((indice_i, indice_j))

        # fonction pour calculer le potentiel
        # itérations sur la grille
        N = 0.0
        for iteration in range(self.nb_iterations):
            N += 1
            for indice_x, i in enumerate(P):
                if indice_x == 0 or indice_x == P.shape[0]-1:
                    continue
                for indice_y, j in enumerate(i):
                    if indice_y == 0 or indice_y == P.shape[1]-1:
                        continue
                    if (indice_x, indice_y) in point_ct:
                        continue

                    P_copie[indice_x, indice_y] = (delta_y**2*(P[indice_x+1][indice_y] + P[indice_x-1][indice_y]) + delta_x**2*(P[indice_x][indice_y+1] + P[indice_x][indice_y-1])) / (2*(delta_x**2 + delta_y**2))




#                    if j+1 == len(P[0]):
#                        P_voisinD = 0
#                    else :
#                        P_voisinD = P[i][j+1]#

#                    if j-1 < 0:
 #                       P_voisinG = 0
  #                  else :
   #                     P_voisinG = P[i][j-1]
#
 #                   if i+1 == len(P):
  #                      P_voisinB = 0
   #                 else :
    #                    P_voisinB = P[i+1][j]
#
 #                   if i-1 < 0:
  #                      P_voisinH = 0
   #                 else :
    #                    P_voisinH = P[i-1][j]

 #                   P_copie[i][j] = (delta_y**2*(P_voisinB + P_voisinH) + delta_x**2*(P_voisinD + P_voisinG)) / 2*(delta_x**2 + delta_y**2)

            ecart = np.max(np.abs(P_copie-P))
            if ecart < 10**(-5): # Comparaison avec erreur
                print(f'iter # {N}')
                break 
            else:
                P = P_copie.copy()

        return(P)


    def _solve_in_polar_coordinate(
            self,
            constant_voltage: ScalarField,
            delta_r: float,
            delta_theta: float
    ) -> ScalarField:
        """
        Solve the Laplace equation to compute the resultant potential field P in 2D-space.

        Parameters
        ----------
        constant_voltage : ScalarField
            A scalar field V : ℝ² → ℝ ; (r, θ) → V(r, θ), where V(r, θ) is the electrical components' voltage at a
            given point (r, θ) in space.
        delta_r : float
            Small discretization of the r-axis.
        delta_theta : float
            Small discretization of the θ-axis.

        Returns
        -------
        potential : ScalarField
            A scalar field P : ℝ² → ℝ ; (r, θ) → P(r, θ), where P(r, θ) is the electric potential at a given point
            (r, θ) in space. The difference between P and V is that P gives the potential in the whole world, i.e inside
            the electrical components and in the empty space between the electrical components, while the field V
            always gives V(r, θ) = 0 if (r, θ) is not a point belonging to an electrical component of the circuit.
        """
                # on a déja la matrice des sources de potentiel
        P = constant_voltage.copy()
        # copie de la première matrice
        P_copie = constant_voltage.copy()
        
        #on initialise une liste vide pour les points constants dans la matrice
        point_ct = []
        for indice_i, i in enumerate(constant_voltage):
            for indice_j, j in enumerate(i):
                if j!= 0:
                    point_ct.append((indice_i, indice_j))

        # fonction pour calculer le potentiel
        # itérations sur la grille
        N = 0
        for iteration in range(self.nb_iterations):
            N += 1
            for indice_r, r in enumerate(P):
                if indice_r == 0 or indice_r == P.shape[0]-1:
                    continue
                for indice_theta, theta in enumerate(r):
                    if indice_theta == 0 or indice_theta == P.shape[1]-1:
                        continue
                    if (indice_r, indice_theta) in point_ct:
                        continue

                    P_copie[indice_r, indice_theta] = (2*r**2*delta_theta**2*(P[indice_r+1][indice_theta]+P[indice_r-1][indice_theta])+r*delta_r*delta_theta**2*(P[indice_r+1][indice_theta]-P[indice_r-1][indice_theta])+2*r**2*delta_r**2*(P[indice_r][indice_theta+1]+P[indice_r][indice_theta-1])) / 4*(r**2*delta_theta + delta_r)

            ecart = np.max(np.abs(P_copie-P))
            if ecart < 10**(-5): # Comparaison avec erreur
                print(f'iter # {N}')
                break 
            else:
                P = P_copie.copy()

        return(P)






#        P = constant_voltage
#        for iteration in range(self.nb_iterations):
#            P_copie = P.copy()
#            N += 1
#            for r in range(P.shape[0]):
#                for theta in range(P.shape[1]):
#                    if theta+1 == len(P[0]):
#                        P_voisinD = 0
#                    else :
#                        P_voisinD = P_copie[r,theta+1]
#
#
#                    if theta-1 < 0:
#                        P_voisinG = 0
#                    else : 
#                        P_voisinG = P_copie[r,theta-1]

#                    if r+1 == len(P):
#                        P_voisinB = 0
#                    else : 
#                        P_voisinB = P_copie[r+1,theta]

#                    if r-1 < 0:
#                        P_voisinH = 0
#                    else :
#                        P_voisinH = P_copie[r-1,theta]

#                    P[r,theta] = (2*r**2*delta_theta**2*(P_voisinB+P_voisinH)+r*delta_r*delta_theta**2*(P_voisinB-P_voisinH)+2*r**2*delta_r**2*(P_voisinD + P_voisinG)) / 4*(r**2*delta_theta + delta_r)
#            
#            if np.max(abs(P_copie - P)) < 10**(-5):
#                print(N)
#                return P_copie

    #   for iteration in range(self.nb_iterations):
    #           P_copie = P.copy()
    #           for r in range(P.shape[0]):
    #               for theta in range(P.shape[1]):
    #                   P[r,theta] = (2*r**2*delta_theta**2*(P_copie[r+1,theta]+P_copie[r-1,theta])+r*delta_r*delta_theta**2*(P_copie[r+1,theta]-P_copie[r-1,theta])+2*r**2*delta_r**2*(P_copie[r,theta+1]+P_copie[r,theta-1])) / 4*(r**2*delta_theta + delta_r)
    #           if np.max(abs(P_copie - P)) < 2.22044604925e-16:
    #               return P_copie
    #       pass

    def solve(
            self,
            constant_voltage: ScalarField,
            coordinate_system: CoordinateSystem,
            delta_q1: float,
            delta_q2: float
    ) -> ScalarField:
        """
        Solve the Laplace equation to compute the resultant potential field P in 2D-space.

        Parameters
        ----------
        constant_voltage : ScalarField
            A scalar field V : ℝ² → ℝ representing a constant voltage field.
        coordinate_system : CoordinateSystem
            Coordinate system.
        delta_q1 : float
            Small discretization of the first axis.
        delta_q2 : float
            Small discretization of the second axis.

        Returns
        -------
        potential : ScalarField
            A scalar field P : ℝ² → ℝ  representing the potential in the 2D world.
        """
        if coordinate_system == CoordinateSystem.CARTESIAN:
            return self._solve_in_cartesian_coordinate(constant_voltage, delta_q1, delta_q2)
        elif coordinate_system == CoordinateSystem.POLAR:
            return self._solve_in_polar_coordinate(constant_voltage, delta_q1, delta_q2)
        else:
            raise NotImplementedError("Only the cartesian and polar coordinates system are implemented.")
